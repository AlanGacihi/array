#include <stdint.h>
#include <stdio.h>
#ifndef MXARR_H
#define MXARR_H

/* maximum number of array dimensions supported */
#define MAX_DIMS 4
/* Error codes generated by the library */
typedef enum
{
    ERR_NONE = 0,
    ERR_MEMORY,
    ERR_VALUE
} ERROR_CODES;
/* global variables defined in mxarr.c file */
extern ERROR_CODES ERROR_CODE;
extern char ERROR_STRING[256];
/* data types supported by array library */
typedef enum
{
    UCHAR_TYPE = 8,
    CHAR_TYPE = 9,
    SHORT_TYPE = 11,
    INT_TYPE = 12,
    FLOAT_TYPE = 13,
    DOUBLE_TYPE = 14,
} ELEMENT_TYPES;
/* marco to compute number of bytes of storage used by each of the above
 * element types
 */
#define ELEMENT_SIZE(x) (1 << ((x - 8) / 2))
/******************************************************************************/
/* C structures (used as classes) */
/******************************************************************************/
/* structure for array objects */
typedef struct
{
    unsigned char dimno;     /* number of dimensions in use */
    ELEMENT_TYPES type;      /* data type stored in array */
    uint32_t dims[MAX_DIMS]; /* array containing the number of elements per
dimension */
    unsigned int elno;       /* total number of elements; equal to product
          of dims in use */
    unsigned char *data;     /* pointer to the data */
} Array;

/**********************PART II***********************************/

/************************************************************************************/
/*Function prototypes and descriptions*/
/************************************************************************************/
void endswap(unsigned char bytes, void *input, void *output);
Array *newarray(uint32_t dim0, ELEMENT_TYPES type);
unsigned char inflatearray(Array *arr, uint32_t dim);
void flatten(Array *arr);
Array *readarray(FILE *fp);
int writearray(FILE *fp, unsigned char bigendian, Array *arr);
void freearray(Array *arr);

/**********************PART II***********************************/
/*implementing matrix algebra operations using the
array functions from Part I. */
/*Element modifier functions.*/
/*The following functions will be used to modify an element in an *array. Each function takes a
*pointer to a double as its input and modifies the value of the *referenced double. These
functions do not return a value, nor do they report errors.
*/
/*********************************************************************************/
void random03(double *x);
void logistic(double *x);
void square(double *x);
/**********************************************************************************/

/*Matrices and Vectors*/
/*The remaining functions are designed to manipulate matrices and vectors. For the purposes of
 *this assignment, a matrix will be strictly defined to be a two-dimensional Array with data type
 *DOUBLE_TYPE and a vector will be a special case of a matrix (follows all the matrix rules) whose
 *first dimension has a size of 1 ( dim[0]==1)
 */
/**********************************************************************************/
unsigned char ismatrix(Array *arr);
unsigned char isvector(Array *arr);
Array *apply(Array *arr, void (*fn)(double *));
Array *copy(Array *arr);
double *matrixgetdouble(Array *matrix, unsigned int i, unsigned int j);
unsigned char *getuchar(Array *arr, unsigned int i, unsigned int j);
Array *matrixcross(Array *multiplier, Array *multiplicand);
/**********************************************************************************/

/*Elementwise matrix operations*/
/*The next three functions are each applied two elements selected from two different matrices at
 *a time and used to compute the value of another element in a third matrix.
 */
/**********************************************************************************/
double mulop(double x, double y);
double addop(double x, double y);
double subop(double x, double y);

/**********************************************************************************/
Array *matrixmatrixop(Array *arr1, Array *arr2, double (*fn)(double, double));
Array *matrixvectorop(Array *arr, Array *vec, double (*fn)(double, double));
Array *scalarmatrixop(double scalar, Array *arr, double (*fn)(double, double));
Array *matrixtranspose(Array *original);
double matrixsum(Array *arr);
Array *matrixonehot(Array *arr);
Array *matrixsumcols(Array *arr);
Array *arrgetmatrix(Array *arr, unsigned int i);

#endif
